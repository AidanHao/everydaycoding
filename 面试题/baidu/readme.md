# 6 . 用过什么AI工具
1. chatGpt
    刻意练习prompt  生成一些简单的前端网页，用于学习
        和沟通类的大模型进行精准的交流
2. Copilot 提示开发效率
3. 最近在学习，transformer , openai技能，对大模型很感兴趣 ， 也在学习langchain，LLM
4. 自己准备一个大模型，介绍你对它的理解

# 7. 讲一讲HTTP的三次握手
    - 三次握手是TCP协议建立连接时产生的
    1. 客户端发送连接请求到服务器端，客户端会进入到一个状态，客户端状态进入 SYN - SENT 状态
    2. 服务端接收到请求的连接报文后，返回一个应答 包含（ACK序号） ，然后服务器端进入 SYN - RECEIVED 状态
    3. 客户端接收到了同意连接的应答后，还要向服务器端发送一个确认收到的报文，再进入ESTABLISHED状态
    这个时候，连接才建立成功
    （TCP里面内置了一个超时重传的机制）
    - 为什么一定要三次握手，两次行不行？
    不行，假设客户端给服务器发送一个建立连接请求A，但是因为网络环境差，这个请求A超时了，那么TCP会启动超时重传机制，再发送一个新的建立连接请求B，服务端接收到B请求后应答，如果此时久完成了建立连接的话，当客户端和服务器端通信完成后，便释放了连接，双方都进入Closed状态，假设此时A请求又抵达了服务端，那么服务器会认为客户端又要建立新的连接，从而应答该请求并进入ESTABLISHED状态，而此时客户端是CLOSED的状态，那么服务端久会一直等待，造成资源浪费

    - 四次挥手
    1. 客户端A认为数据发送完成，向服务端B发送释放连接请求
    2. B收到释放连接请求后，返回一个ACK报文，并进入CLOSE_WAIT状态，此时不再接收A发送的数据，但是B还可以给A发送数据，但是B仍然可以给A发送数据
    3. B如果此时还有没发完的数据，就会继续发送，发完后向A发送释放连接的请求，B进入到LAST_ACK状态
    4. A收到释放连接的请求，向B发送应答，进入CLOSED状态，B收到该应答也进入CLOSED状态

# 8. 说一说跨域

https://192.168.11.25:8080/user
协议号：域名：端口 / 路径

- 同源策略： 协议和-域名-端口号  都相同的地址，浏览器才认为是同源 如果不是同源，浏览器会之间把请求给掐掉

- 跨域：后端返回给浏览器的数据会被浏览器的同源策略给拦截下来 响应接收不到

- 同源策略的目的是数据安全

## 解决跨越 (开发阶段好调试)
http://192.168.31.1:8080 (前端vue)

http://192.168.31.2:8080 (后端go)

1. JSONP 一种手法的称呼，没有实际含义，--- 借助script标签上的src属性不受同源策略影响这一机制，来实现跨越！
    - ajax请求受同源策略的影响，但是script标签的src属性 不受同源策略的影响，且该属性也会导致浏览器发送一个请求

    // 1. 借助script的src属性给后端发送一个请求，且携带一个属性（'callback'）
    // 2. 前端再window对象上添加了一个 callback 函数
    // 3. 后端接收到这个参数'callback'后，将要返回前端的数据 和 这个参数 'callback' 进行拼接 成'callback(data)',并返回
    // 4. 因为前端在window对象上有一个callback函数，后端又返回了一个形如'callback(data)'，浏览器会将该字符串执行成callback的调用

    - 缺点 1. 需要后端配合 2. 只能用于get请求，script的src默认只会以get请求发送请求          