# js数组的方法
1. 增：push unshift splice concat(不影响原数组，返回新数组) 
2. 删：pop shift splice(影响原数组，返回删除的元素) slice(不会影响原数组，返回删除的元素)
3. 改：reverse sort splice 
4. 查：indexOf(没有就是-1) lastIndexOf(返回索引) includes(有就是true，没有就是false) find(返回第一个符合条件的元素,接收一个回调)
5. 遍历方法： 
        map forEach(要拿到原数组进行操作 return 终止不了forEach)  
        filter(返回符合条件的元素,接收三个参数，返回一个满足条件的新数组)
        every并且关系 
        some 或的关系
        reduce(比较特殊 接收两个参数，第一个为回调，第二个为初始值，这个回调函数接收四个参数，第一个参数是上次遍历得到的结果然后是item，i，arr pre没有初始值会挤掉别人的值)

6. 转换：join(将数组转换为字符串)，数组上面的toString是重写了的方法

- forEach map 的区别
1. map 会返回一个新的数组
2. return 无法终止forEach的循环，forEach 没有break 没有continue  forEach 是数组遍历最复杂的遍历方法

# 2. 字符串有哪些方法？
1. 增：concat(不会影响原字符串，返回新字符串)  padStart padEnd
2. 删：slice  subString(两个下标，左闭右开) substr(返回删除的内容 两个参数下标 长度)
3. 改：
    replace(第一个参数是正则，第二个参数是替换的内容) 
    repeat(重复) 
    trim(去除首尾空格) 
    trimLeft(去除左边的空格) 
    trimRight(去除右边的空格) 
    toLowerCase(转小写) 
    toUpperCase(转大写)
    toLocalLowerCase(转小写 基本没有区别 设计到本地语言)

4. 查
    indexOf(没有就是-1)
    lastIndexOf(返回索引)
    includes(有就是true，没有就是false)
    charAt(返回指定位置的字符 相当鸡肋)
    startsWith(第一个参数是字符串，第二个参数是字符串，第三个参数是起始位置，返回布尔值 判断某个字符串是否以某个字符为开头的)
    endsWith(第一个参数是字符串，第二个参数是字符串，第三个参数是起始位置，返回布尔值 判断某个字符串是否以某个字符为结尾的)
    
5. 转换
    charCodeAt
    split


# 3. == 和 === 的区别？
    == 会发生隐式类型转换 === 不会做类型转换
    Array中的toString是被重写了的方法 不是对象的toString
    == 是判断值相等
# 4. 隐式类型转换 说说类型转换
- 什么是类型
js中有原始类型 和 引用类型 的区分

- 有显示类型转换和隐式类型转换
    1. 显示类型转换 一般直接调用构造函数，开发中通常需要将一个类型转为另一个类型时通过调用构造函数实现显示类型转换
    2. 隐式类型转换 当开发中碰到 比较运算符 或者 算术运算符 时 当符合两边的数据类型不一致时，js引擎会自动进行隐式类型转换

# 5. 说说深浅拷贝 手写
    调用栈用来维护作用域当中变量的引用关系
    - 是什么
    拷贝指的是将一个对象中的元素复制到一个新的对象中，拷贝又分为浅拷贝和深拷贝，浅拷贝只拷贝对象的引用地址，深拷贝会层层拷贝每一个属性值，不受原对象修改值的影响

    - 浅拷贝常用方法：
        1. Object.assign()
        2. Object.create()
        3. 解构
        4. concat
        5. slice

    - 深拷贝常见方法
        JSON.parse(JSON.stringify(obj)) - 不能拷贝Symbok function undefined 不能处理循环引用和Bigint
        js自带一个深拷贝方法 structuredClone(obj) - 不能拷贝Symbok function

    - 手写 递归和MessageChannel


    - 函数的拷贝
# 6. 说说你对闭包的理解
    - 是什么？
        闭包是函数的局部变量和函数的执行环境的集合，
        根据词法作用域规则，内部函数一定能访问它外部函数的变量，当内部函数对外部函数中的变量存在引用，且被提到外部函数之外调用，即使外部函数执行完毕，他的执行上下文也无法被完全销毁，而是会将内部函数引用的变量作为一个集合保留在调用栈当中，该集合被称为闭包
        集合是闭包

    - 作用
        - 定义私有变量
        - 封装模块
        - 延长变量的生命周期
        - 单例模式 + 闭包 打造弹窗

    - 缺点：
        - 内存泄漏 

# 7. 说一说原型
    - 是什么？
    原型是一个对象，分为隐式原型和显示原型，隐式原型是对象上的__proto__属性，显示原型是函数上的prototype属性，当我们要访问一个对象的属性时，js引擎不仅会在对象上查找，还会查找对象的隐式原型，顺着隐式原型层层往上查找，直到找到null。对象的隐式原型等于创建该对象的构造函数的显示原型

    1. 函数__proto === Function.Prototype 箭头函数除外
    2. Object.create(null) 没有对象原型


# 8. js当中如何实现继承
    1. 原型链继承 --- 
    缺点：1. 多个实例之间共用了同一个原型！属性会相互影响！引用类型是可以修改的
          2. 子类无法给父类传参

    2. 构造函数继承
    缺点：1. 无法继承父类原型上的属性

    3. 组合继承（经典继承）
    为什么被称为经典继承，因为好用！
    缺点：1. 父类被调用了两次

    4. 原型式继承
    缺点：1. 多个对象公用了同一个原型，属性会相互影响

    5. 寄生组合继承
    没有缺陷！！！！！！
    
    6. class继承

# 9. 说说你对this的理解
    - 是什么？
    this是函数中的一个关键字， 用于代表函数作用域的指向 全局有this

    - 绑定规则  
    1. 默认绑定 -- 函数在哪个词法作用域中生效，函数就指向哪个词法作用域,词法作用域需要找到顶部的，词法作用域要找到底
    2. 隐式绑定 -- 当函数被一个对象所拥有且调用的时候，this指向这个对象
    3. 隐式丢失 -- 多个对象链式调用函数，this指向最近的对象
    4. 显式绑定 -- call() apply() bind()
    5. new绑定  -- this 指向实例对象 

    - 箭头函数
    箭头函数本身没有this概念，如果你在里面写了this，那么this是外部第一个非箭头函数的this
    不可以用做构造函数