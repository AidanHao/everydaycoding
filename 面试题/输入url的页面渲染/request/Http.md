浏览器中最重要的使用最多的协议

# 超文本传输协议HTTP/0.9
html就是超文本
http协议是基于TCP协议的
1. 客户端发送GET请求，请求一个 根路径 /index.html，
2. 服务器接收到请求后，读取对应的html文件，以ASCII的字符流返回给客户端

- 特点：
1. 只有一个请求行，没有请求头和请求体
2. 服务器没有响应头
3. 传输的内容是以ASCII的字符流来传输


# HTTP/1.0
相比于0.9 1.0 版本可以支持多种类型文件的传输

通过引入请求头和响应体来让客户端和服务端更加深入的交流 通过key-value的形式

- 为什么有了请求头和响应头就能支持多种文件的数据传输
请求头：accept：text/html
      accept-encoding：gzip，deflate，br 压缩算法 
      accept-language：zh-CN，zh，en-US，en 浏览器语言
响应体：content-encoding：br
        content-type:text/html,charset=utf-8

# http/1.1
存在哪些问题：传过来的数据不止html，还有css ， js 当你接收到html，tcp就断开连接了，但是加载html时，又需要建立请求拿到css，js等，这就是1.0的缺点
只要是同一个后端，拿到数据时，就不需要重复建立连接，断开连接

持久连接:一个TCP连接建立，可以传输多个http请求，减少了大量TCP连接和断开连接带来的开销
多个TCP并行 
浏览器默认支持6-8个TCP持久连接 
Connection: keep-alive   || close

- 队头阻塞
      1. 管线化：批量发请求 一次性发送所有的http请求 （放弃）
      2. 虚拟机：虚拟机需要绑定ip,

- 虚拟机
      随着时代的发展，一台主机可能会装多个不同的操作系统，比如：windows、linux、macOS、Android、iOS等，
      请求头：HOST字段 表示当前的域名地址 为什么浏览器知道你跨域了呢？其实有一部分是因为HOST字段，HOST的到来就是因为虚拟机技术的成熟 

- 动态内容
      （1.0）content-Length: 1024 这个表示对方要传过来的数据总共大小，可以确定资源有没有被接收完，数据可能是动态的，导致客户端不知道什么时候接收完

      （1.1）Chunk transfer 机制： 用来处理动态内容，将数据分割成若干个任意大小的数据块，每个数据块标记好长度，最后发送一个长度为0的数据块来标志发送完毕

      Cookies 绝大数情况后，归后端操作，这是因为http支持，在响应头里面加一些字段，字段里面的内容能被自动加入cookies中，并且cookies可以设置为可读取或者不可读取状态。可以防止脚本攻击


# HTTP /2.0
TCP有一个慢启动，跑不满带宽，慢启动是为了去解决网络拥塞的问题
慢启动推迟了首次渲染页面的时间

- 1.1的问题：带宽用不满
      1. TCP的慢启动：拥塞控制导致一定会慢启动，慢启动导致页面关键资源加载时间推后，页面首次渲染的时间推迟
      2. TCP多条连接，竞争带宽导致每条TCP链接至中能被分配的带宽大大降低
      3. 队头阻塞 前一个请求延迟的话，后一个请求便无法发送，导致带宽浪费

- 2.0 多路复用
      1. 一个域名只使用一个TCP长连接
      2. 将每一个请求分成一帧一帧的数据进行传输，并打上编号，同时发送给服务端，且可以在重要资源请求中，标记为加急，服务端接收到带有各种标号的数据帧后，可以区分哪个数据帧加急，优先整理和响应该请求的数据帧 （通过引入了二进制分帧层实习多路复用）
      现在基本使用的就是http2 http2所处的环境有问题，tcp


# HTTP/HTTPS
GET / images / logo.png HTTP / 1.1

副作用：对服务器上的资源做变更，会影响服务器上的资源 
幂等：发送m次或者n次请求，服务器上的资源的状态是一致的  注册十次和二十次，不是幂等，更改文章十次和二十次，是幂等

- GET VS POST （副作用和幂等）
      1. GET多用于无副作用，幂等的场景，而post用于有副作用，不幂等的场景
      2. GET请求，能缓存，而POST不能
      3. POST相对安全一点，POST的参数是在请求体中，GET的参数是拼接在url中
      4. URL的长度是有限的，所以GET请求会受影响，而POST不会 GET长度有限制，POST没有
      5. POST支持更多的编码类型，且不对数据类型做限制 比如说 koa无法识别post携带的参数


- 状态码：200 请求成功
        204 响应成功，没有数据
        205
        206

        
        301 永久重定向
        302 临时重定向
        303
        304

        400 请求格式错误
        401 没有权限访问
        403 禁止访问
        404 找不到资源

        500
        501 服务器不支持当前请求
        502 
        503 服务器暂时无法处理请求

- TLS 协议
      HTTPS = HTTP + TLS 

      TLS 应用层之下，传输层之上

      1. 对称加密 
            双方都有相同的密钥，双方都知道如何加密和解密 

            如何让双方都具有相同的密钥，通过网络传输该密钥，一旦被截获，之后的内容加密也无意义

                  我要给你说的话，要加密，你给我说的话，要加密，你需要知道
                  两边都要知道如何加密，如何解密
      2. 非对称加密
            服务端生成一个公钥和私钥，将公钥发布出来，客户端接收到公钥后，生成一个密钥，然后通过公钥加密密钥，传输给服务端，服务端用独有的私钥解密得到密钥。现在两端就具有一个相同的密钥了

# HTTP 3.0
      - 2.0 的缺陷：
            1. TCP的队头阻塞：当单个数据包丢生时，TCP会暂停后续的包的传输，先重传丢生的数据包，在这个过程当中，只要存在一个包丢生就一定存在阻塞的问题 
            2. TCP的慢启动    

      - TCP协议僵化：TCP常用于物理层，一旦TCP修改，路由器，交换机，防火墙等等全部失效，全部要更新
            操作系统也是导致TCP僵化的原因


      - HTTP3.0不再基于TCP协议
      - 基于QUIC协议：基于UDP协议，在UDP上实现了类似于TCP的多路数据流，可靠性传输等功能
            1. 实现了类似于TCP的流量控制和可靠性传输
            2. 集成了TLS加密功能
            3. 实现了HTTP2中的多路复用

      - 目前的挑战：浏览器和服务器都要对QUIC协议进行支持，普及不够
